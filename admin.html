from fastapi import FastAPI, HTTPException, Depends, Header
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import RedirectResponse
from contextlib import asynccontextmanager
from pydantic import BaseModel
from datetime import datetime, timedelta
import aiosqlite, hashlib, hmac, secrets, httpx, json, os, base64
from cryptography.fernet import Fernet
import uvicorn

SECRET_KEY        = os.getenv("SECRET_KEY",        "ryopos-secret-2024-commercial-key-xyz")
JWT_SECRET        = os.getenv("JWT_SECRET",        "change-this-jwt-secret-!!!")
ADMIN_KEY         = os.getenv("ADMIN_KEY",         "change-admin-key-!!!")
ZARINPAL_MERCHANT = os.getenv("ZARINPAL_MERCHANT", "your-merchant-id-here")
CALLBACK_URL      = os.getenv("CALLBACK_URL",      "https://your-server.railway.app/payment/verify")
FRONTEND_URL      = os.getenv("FRONTEND_URL",      "https://yourusername.github.io/ryopos-website")
DB_PATH           = os.getenv("DB_PATH",           "ryopos.db")

PRICES = {"basic": 5000000, "premium": 7000000}
ZARINPAL_REQUEST = "https://api.zarinpal.com/pg/v4/payment/request.json"
ZARINPAL_VERIFY  = "https://api.zarinpal.com/pg/v4/payment/verify.json"
ZARINPAL_PAY     = "https://www.zarinpal.com/pg/StartPay/"


def _get_fernet():
    key = hashlib.sha256(SECRET_KEY.encode()).digest()
    return Fernet(base64.urlsafe_b64encode(key))


def generate_license_key(hardware_id: str, days: int = 36500) -> str:
    # فرمت خوانا: RYO-XXXX-XXXX-XXXX
    part1 = secrets.token_hex(2).upper()
    part2 = secrets.token_hex(2).upper()
    part3 = secrets.token_hex(2).upper()
    return f"RYO-{part1}-{part2}-{part3}"


def make_token(user_id: int) -> str:
    raw = f"{user_id}:{secrets.token_hex(16)}"
    sig = hmac.new(JWT_SECRET.encode(), raw.encode(), hashlib.sha256).hexdigest()
    return base64.urlsafe_b64encode(f"{raw}:{sig}".encode()).decode()


def verify_token(token: str) -> int:
    try:
        decoded = base64.urlsafe_b64decode(token.encode()).decode()
        parts = decoded.rsplit(":", 1)
        raw, sig = parts[0], parts[1]
        expected = hmac.new(JWT_SECRET.encode(), raw.encode(), hashlib.sha256).hexdigest()
        if not hmac.compare_digest(sig, expected):
            raise ValueError
        return int(raw.split(":")[0])
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid token")


async def get_current_user(authorization: str = Header(None)):
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Not logged in")
    return verify_token(authorization[7:])


def verify_admin(x_admin_key: str = Header(None)):
    if x_admin_key != ADMIN_KEY:
        raise HTTPException(status_code=401, detail="Unauthorized")


async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.executescript("""
            CREATE TABLE IF NOT EXISTS users (
                id            INTEGER PRIMARY KEY AUTOINCREMENT,
                fullname      TEXT NOT NULL,
                phone         TEXT UNIQUE NOT NULL,
                email         TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                created_at    TEXT NOT NULL
            );
            CREATE TABLE IF NOT EXISTS purchases (
                id            INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id       INTEGER NOT NULL,
                plan          TEXT NOT NULL,
                amount        INTEGER NOT NULL,
                hardware_id   TEXT,
                license_key   TEXT,
                authority     TEXT UNIQUE,
                ref_id        TEXT,
                status        TEXT DEFAULT 'pending',
                created_at    TEXT NOT NULL,
                paid_at       TEXT
            );
            CREATE TABLE IF NOT EXISTS trial_devices (
                hardware_id TEXT PRIMARY KEY,
                created_at  TEXT NOT NULL
            );
        """)
        await db.commit()


@asynccontextmanager
async def lifespan(app: FastAPI):
    await init_db()
    yield


app = FastAPI(title="RYOPOS Server", lifespan=lifespan)
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_methods=["*"], allow_headers=["*"])


class RegisterModel(BaseModel):
    fullname: str
    phone: str
    email: str
    password: str

class LoginModel(BaseModel):
    email: str
    password: str

class BuyModel(BaseModel):
    plan: str

class HardwareModel(BaseModel):
    purchase_id: int
    hardware_id: str

class ActivateModel(BaseModel):
    hardware_id: str
    license_code: str

class ManualLicenseModel(BaseModel):
    hardware_id: str
    plan: str = "basic"
    days: int = 36500
    user_email: str = ""


@app.get("/")
async def root():
    return {"status": "RYOPOS Server v2.0 OK"}


@app.post("/auth/register")
async def register(req: RegisterModel):
    pw_hash = hashlib.sha256(req.password.encode()).hexdigest()
    now = datetime.utcnow().isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        try:
            cur = await db.execute(
                "INSERT INTO users (fullname,phone,email,password_hash,created_at) VALUES(?,?,?,?,?)",
                (req.fullname, req.phone, req.email, pw_hash, now)
            )
            await db.commit()
            user_id = cur.lastrowid
        except aiosqlite.IntegrityError:
            raise HTTPException(400, "Email or phone already registered")
    return {"token": make_token(user_id), "fullname": req.fullname}


@app.post("/auth/login")
async def login(req: LoginModel):
    pw_hash = hashlib.sha256(req.password.encode()).hexdigest()
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM users WHERE email=? AND password_hash=?", (req.email, pw_hash)
        ) as cur:
            user = await cur.fetchone()
    if not user:
        raise HTTPException(401, "Wrong email or password")
    return {"token": make_token(user["id"]), "fullname": user["fullname"]}


@app.get("/auth/me")
async def me(user_id: int = Depends(get_current_user)):
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT id,fullname,phone,email,created_at FROM users WHERE id=?", (user_id,)
        ) as cur:
            user = await cur.fetchone()
    if not user:
        raise HTTPException(404, "User not found")
    return dict(user)


@app.get("/purchases")
async def my_purchases(user_id: int = Depends(get_current_user)):
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM purchases WHERE user_id=? ORDER BY created_at DESC", (user_id,)
        ) as cur:
            rows = await cur.fetchall()
    return [dict(r) for r in rows]


@app.post("/payment/request")
async def payment_request(req: BuyModel, user_id: int = Depends(get_current_user)):
    if req.plan not in PRICES:
        raise HTTPException(400, "Invalid plan")
    amount = PRICES[req.plan]
    now = datetime.utcnow().isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        cur = await db.execute(
            "INSERT INTO purchases (user_id,plan,amount,status,created_at) VALUES(?,?,?,'pending',?)",
            (user_id, req.plan, amount, now)
        )
        await db.commit()
        purchase_id = cur.lastrowid

    payload = {
        "merchant_id":  ZARINPAL_MERCHANT,
        "amount":       amount,
        "description":  f"RYOPOS License - {req.plan}",
        "callback_url": f"{CALLBACK_URL}?purchase_id={purchase_id}",
    }
    async with httpx.AsyncClient() as client:
        try:
            resp = await client.post(ZARINPAL_REQUEST, json=payload, timeout=15)
            data = resp.json()
        except Exception as e:
            raise HTTPException(503, f"ZarinPal error: {e}")

    if data.get("data", {}).get("code") != 100:
        raise HTTPException(400, f"ZarinPal error: {data.get('errors', data)}")

    authority = data["data"]["authority"]
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("UPDATE purchases SET authority=? WHERE id=?", (authority, purchase_id))
        await db.commit()

    return {"payment_url": f"{ZARINPAL_PAY}{authority}", "purchase_id": purchase_id, "amount": amount}


@app.get("/payment/verify")
async def payment_verify(Authority: str, Status: str, purchase_id: int):
    fail_url = f"{FRONTEND_URL}?payment=failed"
    ok_url   = f"{FRONTEND_URL}?payment=success&purchase_id={purchase_id}"

    if Status != "OK":
        return RedirectResponse(fail_url)

    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT * FROM purchases WHERE id=?", (purchase_id,)) as cur:
            purchase = await cur.fetchone()

    if not purchase:
        return RedirectResponse(fail_url)
    if purchase["status"] == "paid":
        return RedirectResponse(ok_url)

    async with httpx.AsyncClient() as client:
        try:
            resp = await client.post(ZARINPAL_VERIFY, json={
                "merchant_id": ZARINPAL_MERCHANT,
                "amount":      purchase["amount"],
                "authority":   Authority,
            }, timeout=15)
            data = resp.json()
        except Exception:
            return RedirectResponse(fail_url)

    code = data.get("data", {}).get("code")
    if code not in (100, 101):
        return RedirectResponse(fail_url)

    ref_id = str(data["data"]["ref_id"])
    now = datetime.utcnow().isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE purchases SET status='paid', ref_id=?, paid_at=? WHERE id=?",
            (ref_id, now, purchase_id)
        )
        await db.commit()

    return RedirectResponse(ok_url)


@app.post("/purchases/set-hardware")
async def set_hardware(req: HardwareModel, user_id: int = Depends(get_current_user)):
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM purchases WHERE id=? AND user_id=?", (req.purchase_id, user_id)
        ) as cur:
            purchase = await cur.fetchone()

    if not purchase:
        raise HTTPException(404, "Purchase not found")
    if purchase["status"] != "paid":
        raise HTTPException(400, "Purchase not paid yet")
    if purchase["license_key"]:
        return {"license_key": purchase["license_key"], "hardware_id": purchase["hardware_id"], "plan": purchase["plan"]}

    license_key = generate_license_key(req.hardware_id)
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE purchases SET hardware_id=?, license_key=? WHERE id=?",
            (req.hardware_id, license_key, req.purchase_id)
        )
        await db.commit()

    return {"license_key": license_key, "hardware_id": req.hardware_id, "plan": purchase["plan"]}


@app.get("/api/status/{hardware_id}")
async def license_status(hardware_id: str):
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM purchases WHERE hardware_id=? AND status='paid' ORDER BY paid_at DESC LIMIT 1",
            (hardware_id,)
        ) as cur:
            purchase = await cur.fetchone()

    if purchase:
        return {
            "status":         "active",
            "plan":           purchase["plan"],
            "days_remaining": -1,
            "activated_at":   purchase["paid_at"],
            "token":          purchase["license_key"][:32] if purchase["license_key"] else "",
        }

    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT created_at FROM trial_devices WHERE hardware_id=?", (hardware_id,)
        ) as cur:
            row = await cur.fetchone()

    if row:
        first_seen = datetime.fromisoformat(row["created_at"])
        elapsed    = (datetime.utcnow() - first_seen).days
        remaining  = max(0, 30 - elapsed)
    else:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT OR IGNORE INTO trial_devices(hardware_id, created_at) VALUES(?,?)",
                (hardware_id, datetime.utcnow().isoformat())
            )
            await db.commit()
        remaining = 30

    return {
        "status":         "trial" if remaining > 0 else "expired",
        "days_remaining": remaining,
        "plan":           "none",
    }


@app.post("/api/activate")
async def activate_with_key(req: ActivateModel):
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM purchases WHERE upper(license_key)=upper(?) AND status='paid'",
            (req.license_code,)
        ) as cur:
            purchase = await cur.fetchone()

    if not purchase:
        raise HTTPException(404, "License key not found or invalid")

    existing_hw = purchase["hardware_id"]
    if existing_hw and existing_hw != req.hardware_id:
        raise HTTPException(400, "This license is already activated on another device")

    if not existing_hw:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "UPDATE purchases SET hardware_id=? WHERE id=?",
                (req.hardware_id, purchase["id"])
            )
            await db.commit()

    return {
        "success": True,
        "plan":    purchase["plan"],
        "token":   purchase["license_key"],
        "message": "License activated successfully",
    }


@app.post("/api/register")
async def register_installation(data: dict):
    return {"status": "ok", "registered": True}


@app.get("/admin/users", dependencies=[Depends(verify_admin)])
async def admin_users():
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT id,fullname,phone,email,created_at FROM users ORDER BY id DESC"
        ) as cur:
            rows = await cur.fetchall()
    return [dict(r) for r in rows]


@app.get("/admin/purchases", dependencies=[Depends(verify_admin)])
async def admin_purchases():
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT * FROM purchases ORDER BY id DESC") as cur:
            rows = await cur.fetchall()
    return [dict(r) for r in rows]


@app.post("/admin/generate-license", dependencies=[Depends(verify_admin)])
async def admin_generate_license(req: ManualLicenseModel):
    if req.plan not in ("basic", "premium"):
        raise HTTPException(400, "Invalid plan")

    license_key = generate_license_key(req.hardware_id, req.days)
    now = datetime.utcnow().isoformat()
    user_id = 0

    if req.user_email:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            async with db.execute(
                "SELECT id FROM users WHERE email=?", (req.user_email,)
            ) as cur:
                user = await cur.fetchone()
        if not user:
            raise HTTPException(404, "User email not found - user must register first")
        user_id = user["id"]

    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO purchases (user_id,plan,amount,hardware_id,license_key,status,created_at,paid_at) VALUES(?,?,0,?,?,'paid',?,?)",
            (user_id, req.plan, req.hardware_id, license_key, now, now)
        )
        await db.commit()

    return {"license_key": license_key, "hardware_id": req.hardware_id, "plan": req.plan, "user_id": user_id}


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=int(os.getenv("PORT", 8000)), reload=True)